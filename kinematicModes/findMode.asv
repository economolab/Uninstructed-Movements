%% Function for finding modes of neural activity that are defined by the kinematics of different features
% INPUTS:
% obj = current object
% feat = the position or kinematic data for the feature you have specified
% params variable

% OUTPUTS:
% mode = the dimension of neural activity that is defined by which cells
% have activity most correlated with the specified feature
% dat =

function [mode, dat] = findMode(obj, feat, params)

fr = cat(3, obj.trialpsth_cond{params.cond});   % Concatenate the single-trial PSTHs from the specified conditions (time x cells x trials)
fs = 1./mean(diff(obj.time));                   % Find the sampling frequency for the time vector


% Define and implement a Butterworth filter for the single-trial PSTHs
[b,a] = butter(2,params.fcut./fs./2);           % Butterworth filter: 2nd order, cutoff frequency determined using params.fcut and the sampling rate
                                                % b = filter coefficient vector of numerator
                                                % a = filter coefficient vector of denominators

filtfr = filtfilt(b, a, fr);                    % Digital filtering of the single-trial PSTHs with the filter described by vectors A and B

filtfr = permute(filtfr(params.tix,:, :), [ 1 3 2]);    % Re-order the dimensions of filtfr (switch the 2nd and 3rd dimensions)
filtfr = reshape(filtfr, size(filtfr, 1)*size(filtfr, 2), size(filtfr, 3));   % (time*trials x cells)

if params.fa                                    % If you want to use factor analysis...
    [~,~,~,~,dat]  = factoran(filtfr,10);       % Reduce the number of neural dimensions
else
    dat = filtfr;                               % Otherwise use the filtered single-trial firing rates for each cell 
end


% Find the mode using the specified method
feat = feat(params.tix, :);                     % Only take the desired time-points 
feat = feat(:);                                 % Make into one column vector 
feat(isnan(feat)) = 0;

switch params.method
    case 'xcorr'
        mode = doXCorr(dat, feat);

    case 'regress'
        mode = regress(feat,dat);

        mode = mode./sum(abs(mode));
    otherwise
        mode = zeros(1, 1);
        return;

end

dat = reshape(dat, numel(params.tix), size(fr, 3), size(dat, 2));
dat = permute(dat, [1 3 2]);

