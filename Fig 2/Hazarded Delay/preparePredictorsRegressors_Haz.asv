function [X,Y,delLength,par] = preparePredictorsRegressors_Haz(par, sessix, kin, del,params) 
% predict 'trialdat' from par.feats (kinematic features of interest)


    stdcutoff = 100;

    % trials
    par.trials.all = cell2mat(params(sessix).trialid(par.cond2use)');                   % All trials from all conditions you are decoding for
                                                               
    delLength = del(sessix).delaylen(par.trials.all);                                   % Store the associated delay length for each of these conditions                   
    %%%% Want to do train/test split on each delay length individually)

    % get DR rhit and DR lhit trials so that we can match them
    % up with the test trials later
    par.trials.Rhit = params(sessix).trialid{par.cond2use(1)}; 
    par.trials.Lhit = params(sessix).trialid{par.cond2use(2)}; 

    % partition train and test
    lengths = unique(delLength);
    deltrain = [];
    deltest = [];
    for del = 1:length(lengths)
            delixs = find(delLength==lengths(del));
            nTrials = length(delixs);
            nTrain = floor(nTrials*par.train);
            temptrain = randsample(delixs,nTrain,false);                         % Trials for training set
            
            temptest = find(~ismember(delixs,temptrain));
            deltrain = [deltrain; temptrain];
            deltest = [deltest; temptest];
    end
    par.trials.train = deltrain;
    par.trials.test = deltest;       % Trials for testing set 

    % input data (kinematic data)                           
    par.featix = find(ismember(kin(sessix).featLeg,par.feats));                         % Find any feature indices that contain the strings in 'par.feats'

    X.train = kin(sessix).dat_std(par.timerange,par.trials.train,par.featix);           % (time,trials,feats)
    X.train = fillmissing(X.train,'constant',0);                                        % Make NaNs into zeros
    outlierx = find(abs(X.train)>stdcutoff);                                            % If any of the regressors (movement values) have a very large value (greater than 100), label it as an outlier
    if ~isempty(outlierx)                   
        X.train(outlierx) = 0;                                                          % Set these outlier values to 0
    end
    X.size.train = size(X.train);
    X.train = reshape(X.train, size(X.train,1)*size(X.train,2),size(X.train,3));        % RESHAPE to: (time * trials, feats)

    
    X.test = kin(sessix).dat_std(par.timerange,par.trials.test,par.featix);             % (time,trials,feats)
    X.size.test = size(X.test);
    X.test = reshape(X.test, size(X.test,1)*size(X.test,2),size(X.test,3));             % RESHAPE to: (time * trials, feats)

    % reshape train and test data to account for prediction bin size
    X.train = reshapePredictors(X.train,par);                                           % (time*trials, binWidth, feats)
    X.test = reshapePredictors(X.test,par);

    % flatten inputs
    % if you're using a model with recurrence, don't flatten
    X.train = reshape(X.train,size(X.train,1),size(X.train,2)*size(X.train,3));         % Make into (time*trials, binWidth*feats)
    X.test = reshape(X.test,size(X.test,1),size(X.test,2)*size(X.test,3));

    % output data
    Y.train = del(sessix).singleProj(par.timerange,par.trials.train);                   % (time,trials);
    Y.size.train = size(Y.train);
    Y.train = reshape(Y.train, size(Y.train,1)*size(Y.train,2),size(Y.train,3));        % (time * trials)

    Y.test = del(sessix).singleProj(par.timerange,par.trials.test);
    Y.size.test = size(Y.test);
    Y.test = reshape(Y.test, size(Y.test,1)*size(Y.test,2),size(Y.test,3));

    % standardize data
    % standardize both train and test sets using train set statistics
    % can also standardize using specific time points (presample for example)
    X.mu = mean(X.train,1,'omitnan');
    X.sigma = std(X.train,[],1,'omitnan');
    X.train = (X.train - X.mu) ./ X.sigma;
    if ~par.test==0
        X.test = (X.test - X.mu) ./ X.sigma;
    end

    Y.mu = mean(Y.train,1,'omitnan');
    Y.sigma = std(Y.train,[],1,'omitnan');
    Y.train = (Y.train - Y.mu) ./ Y.sigma;
    if ~par.test==0
        Y.test = (Y.test - Y.mu) ./ Y.sigma;
    end

    % fill missing values in kinematics
    X.train = fillmissing(X.train,'constant',0);
    Y.train = fillmissing(Y.train,'nearest');
    X.test = fillmissing(X.test,'constant',0);
    Y.test = fillmissing(Y.test,'nearest');