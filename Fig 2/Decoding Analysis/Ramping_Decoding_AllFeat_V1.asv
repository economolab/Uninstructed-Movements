% DECODING CDlate FROM ALL KINEMATIC FEATURES
clear,clc,close all

whichcomp = 'LabPC';                                                % LabPC or Laptop

% Base path for code depending on laptop or lab PC
if strcmp(whichcomp,'LabPC')
    basepth = 'C:\Code';
elseif strcmp(whichcomp,'Laptop')
    basepth = 'C:\Users\Jackie\Documents\Grad School\Economo Lab\Code';
end

% add paths
utilspth = [basepth '\Munib Uninstruct Move\uninstructedMovements_v2'];
addpath(genpath(fullfile(utilspth,'DataLoadingScripts')));
addpath(genpath(fullfile(utilspth,'funcs')));
addpath(genpath(fullfile(utilspth,'utils')));
addpath(genpath(fullfile(utilspth,'fig1')));
figpth = [basepth  '\Uninstructed-Movements\Fig 2'];
addpath(genpath(fullfile(figpth,'funcs')));
%% PARAMETERS
params.alignEvent          = 'goCue'; % 'jawOnset' 'goCue'  'moveOnset'  'firstLick'  'lastLick'

% time warping only operates on neural data for now.
% TODO: time warp for video and bpod data
params.timeWarp            = 0;  % piecewise linear time warping - each lick duration on each trial gets warped to median lick duration for that lick across trials
params.nLicks              = 20; % number of post go cue licks to calculate median lick duration for and warp individual trials to

params.lowFR               = 1; % remove clusters with firing rates across all trials less than this val

% set conditions to calculate PSTHs for
params.condition(1)     = {'(hit|miss|no)'};                             % all trials
params.condition(end+1) = {'R&hit&~stim.enable&~autowater&~early'};             % right hits, no stim, aw off
params.condition(end+1) = {'L&hit&~stim.enable&~autowater&~early'};             % left hits, no stim, aw off
params.condition(end+1) = {'R&miss&~stim.enable&~autowater&~early'};            % error right, no stim, aw off
params.condition(end+1) = {'L&miss&~stim.enable&~autowater&~early'};            % error left, no stim, aw off
params.condition(end+1) = {'R&no&~stim.enable&~autowater&~early'};              % no right, no stim, aw off
params.condition(end+1) = {'L&no&~stim.enable&~autowater&~early'};              % no left, no stim, aw off
params.condition(end+1) = {'hit&~stim.enable&~autowater&~early'};               % all hits, no stim, aw off


params.tmin = -3;
params.tmax = 2.5;
params.dt = (1/100)*3;

% smooth with causal gaussian kernel
params.smooth = 15;

% cluster qualities to use
params.quality = {'all'}; % accepts any cell array of strings - special character 'all' returns clusters of any quality


params.traj_features = {{'tongue','left_tongue','right_tongue','jaw','trident','nose'},...
    {'top_tongue','topleft_tongue','bottom_tongue','bottomleft_tongue','jaw','top_nostril','bottom_nostril'}};

params.feat_varToExplain = 80; % num factors for dim reduction of video features should explain this much variance

params.N_varToExplain = 80; % keep num dims that explains this much variance in neural data (when doing n/p)

params.advance_movement = 0;
params.bctype = 'reflect'; % options are : reflect  zeropad  none
%% SPECIFY DATA TO LOAD

if strcmp(whichcomp,'LabPC')
    datapth = 'C:\Users\Jackie Birnbaum\Documents\Data';
elseif strcmp(whichcomp,'Laptop')
    datapth = 'C:\Users\Jackie\Documents\Grad School\Economo Lab';
end

meta = [];

% --- ALM ---
meta = loadJEB13_ALMVideo(meta,datapth);
meta = loadJEB6_ALMVideo(meta,datapth);
meta = loadJEB7_ALMVideo(meta,datapth);
meta = loadEKH1_ALMVideo(meta,datapth);
meta = loadEKH3_ALMVideo(meta,datapth);
meta = loadJGR2_ALMVideo(meta,datapth);
meta = loadJGR3_ALMVideo(meta,datapth);
meta = loadJEB14_ALMVideo(meta,datapth);
meta = loadJEB15_ALMVideo(meta,datapth);

params.probe = {meta.probe}; % put probe numbers into params, one entry for element in meta, just so i don't have to change code i've already written

%% LOAD DATA

% ----------------------------------------------
% -- Neural Data --
% obj (struct array) - one entry per session
% params (struct array) - one entry per session
% ----------------------------------------------
[obj,params] = loadSessionData(meta,params);
%%
% ------------------------------------------
% -- Motion Energy --
% me (struct array) - one entry per session
% ------------------------------------------
for sessix = 1:numel(meta)
    disp(['Loading ME for session ' num2str(sessix)])
    me(sessix) = loadMotionEnergy(obj(sessix), meta(sessix), params(sessix), datapth);
end
%% Calculate all CDs and find single trial projections
clearvars -except obj meta params me sav kin

disp('----Calculating coding dimensions----')
cond2use = [2 3 6 7]; % right hits, left hits (corresponding to PARAMS.CONDITION)
inclramp = 'yes';
rampcond = 8;
cond2proj = 2:7;  % right hits, left hits, right miss, left miss, right no, left no (corresponding to null/potent psths in rez)
cond2use_trialdat = [2 3]; % for calculating selectivity explained in full neural pop
regr = getCodingDimensions_2afc(obj,params,cond2use,rampcond,cond2proj, inclramp);

disp('----Projecting single trials onto CDlate----')
cd = 'ramping';
regr = getSingleTrialProjs(regr,obj,cd);
%% Load kinematic data
nSessions = numel(meta);
for sessix = 1:numel(meta)
    message = strcat('----Getting kinematic data for session',{' '},num2str(sessix), {' '},'out of',{' '},num2str(nSessions),'----');
    disp(message)
    kin(sessix) = getKinematics(obj(sessix), me(sessix), params(sessix));
end
%% Plot example of motion energy and ramping mode, averaged across right and left trials
colors = getColors();

nSessions = numel(meta);
cond2plot = [2 3];
MEix = find(strcmp(kin(1).featLeg),'motion_energy');

times.trialstart = median(obj(1).bp.ev.bitStart)-median(obj(1).bp.ev.(params(1).alignEvent));
times.startix = find(obj(1).time>times.trialstart,1,'first');
times.samp = median(obj(1).bp.ev.sample)-median(obj(1).bp.ev.(params(1).alignEvent));
times.stopix = find(obj(1).time<times.samp,1,'last');

cols
for sessix = 1:numel(meta)
    for c = 1:length(cond2plot)
        cond = cond2plot(c);
        condtrix = params(sessix).trialid{cond};
        condME = squeeze(kin(sessix).dat(:,condtrix,MEix));
        presampME = mean(condME(times.startix:times.stopix,:),1,'omitnan');
        presampME = mean(presampME);
        condME = condME-presampME;    
        nTrials = size(condME,2);

        subplot(2,1,1)
        toplot = condME;
        err = 1.96*(std(condME)./sqrt(nTrials));
        ax = gca;
        shadedErrorBar(time,toplot,err,{'Color',col,'LineWidth',2,'LineStyle',linestyle},alph,ax); hold on;

        subplot(2,1,2)
    end
end
%% Predict CDRamping from DLC features
clearvars -except datapth kin me meta obj params regr nSessions
clc;

% params for decoding
rez.nFolds = 4;                                     % number of iterations (bootstrap)
rez.binSize = 30;                                   % Bin size to decode over (in milliseconds)
difTime = params(1).dt*1000;                        % Convert time-difference from s to ms
rez.dt = floor(rez.binSize / difTime);              % How many samples confer your bin size
rez.tm = obj(1).time(1:rez.dt:numel(obj(1).time));  % Create a new time axis over which to decode (based on the bin size that you want)
rez.numT = numel(rez.tm);                           % Number of time-points
rez.train = 1;                                      % fraction of trials to use for training (1-train for testing)

% match number of right and left hits, and right and left misses
cond2use = 2:5;                                     % Which conditions you want to include (R hit, L hit, R miss, L miss)
hitcond = [1 2];                                    % Which conditions out of cond2use are hit
misscond = [3 4];                                   % Which conditions out of cond2use are miss

% Do the decoding of CDTrialType from all DLC features
%%% trueVals = (1x1) struct with fields 'Rhit' and 'Lhit'.  Each of these fields is an (nSessions x 1) cell array.  
%%% Each cell contains (time x trials) array of the true CDTrialType values 
%%% modelpred is structured in the same way but this reflects the prediction of the multiple linear regression model
[trueVals, modelpred] = doCDTrialTypeDecoding_fromDLC(nSessions, kin, obj, cond2use, hitcond, misscond, regr,rez, params);

 disp('---FINISHED DECODING FOR ALL SESSIONS---')
%% Make heatmaps for a single session showing CDTrialType across trials and predicted CDTrialType

% Times that you want to use to sort CDTrialType
start = find(obj(1).time>-0.9,1,'first');
stop = find(obj(1).time<-0.05,1,'last');

goodsess = [4,6,19,21];

cond2plot = {'Lhit','Rhit'};
for sessix = 21                                                                  % For each session...
    figure();
    cnt = 0;
    tempTrue = [];
    tempPred = [];
    % Combine the true values for CDTrialType and the model predicted
    % values across conditions
    % tempTrue = (time x [num left trials + num right trials])
    for c = 1:length(cond2plot)                                                 % For left and right trials...
        cond = cond2plot{c};
        currTrue = trueVals.(cond){sessix};                                     % Get the true single trial CDTrialType projections for that condition and session
        tempTrue = [tempTrue,currTrue];
        currPred = modelpred.(cond){sessix};                                    % Get the model predicted single trial CDTrialType projections
        tempPred = [tempPred,currPred];                                        
    end

    [~,sortix] = sort(mean(tempTrue(start:stop,:),1,'omitnan'),'descend');      % Sort the true projections by average magnitude during the delay period
    True2plot = tempTrue(:,sortix);
    Pred2plot = tempPred(:,sortix);                                             % Sort the model predictions in the same order

    nTrials = size(True2plot,2);                                                 % Total number of trials that are being plotted                                               
    ax1 = subplot(1,2,1);                                                       % Plot true CDTrialType data on left subplot
    imagesc(obj(sessix).time,1:nTrials,True2plot'); hold on                      % Heatmap of true data (sorted left trials will be on top, then a white line, then sorted right trials)
    
    ax2 = subplot(1,2,2);
    imagesc(obj(sessix).time,1:nTrials,Pred2plot'); hold on
    title(ax1,'CDRamping - data')
    colorbar(ax1)
    colormap(linspecer)
    xlabel(ax1,'Time from go cue (s)')
    xline(ax1,0,'k--','LineWidth',1)
    xline(ax1,-0.9,'k--','LineWidth',1)
    xline(ax1,-2.2,'k--','LineWidth',1)
    xlim(ax1,[-2.5 0])
    
    title(ax2,'Model prediction')
    xlabel(ax2,'Time from go cue (s)')
    xline(ax2,0,'k--','LineWidth',1)
    xline(ax2,-0.9,'k--','LineWidth',1)
    xline(ax2,-2.2,'k--','LineWidth',1)
    xlim(ax2,[-2.5 0])
    colorbar(ax2)
    colormap(linspecer)

    sgtitle(['Example session:  ' meta(sessix).anm ' ' meta(sessix).date])
end
%% Example plots by session for relating predicted and true CDTrialType
delR2_ALL = [];
exsess = 21;
for sessix = exsess %1:length(meta)
    %%% Plot a scatter plot for a single session of true CDlate and predicted CDlate for each trial
    %%% Each dot = an average value of CDlate during the delay period 
    figure();
    tempR2 = Scatter_ModelPred_TrueCDTrialType(trueVals, modelpred, sessix, start, stop,meta);
    % Save R2 value for that session
    delR2_ALL = [delR2_ALL, tempR2];

    % Calculate averages and standard deviation for true CD and predicted CD  this session
    [avgCD,stdCD] = getAvgStd(trueVals,modelpred,sessix);
    
    colors = getColors();
    alph  = 0.2;
    
    %%% Plot an example session of CDlate prediction vs true value
    figure();
    plotExampleCDTrialType_Pred(colors, obj, rez, meta, avgCD, stdCD, sessix, trueVals,alph, tempR2);
    
    %close all
end
%% Plot bar plot to show average R2 values across sessions
colors = getColors();
                              
anmNames_all = {'JEB13','JEB13','JEB13','JEB13','JEB13','JEB13',...
    'JEB6', 'JEB7', 'JEB7', 'EKH1','JGR2','JGR2','JGR3','JEB14','JEB14','JEB14','JEB14',...
    'JEB15','JEB15','JEB15','JEB15'};

nSessions = numel(anmNames_all);
uniqueAnm = unique(anmNames_all);

exsess = 21;                                                             % The index of the session that you want to be highlighted
markerSize = 60;
figure();
bar(mean(delR2_ALL),'FaceColor',colors.afc); hold on;                   % Plot the average R2 value across all sessions
for sessix = 1:nSessions
    curranm = anmNames_all{sessix};                 % Get the name of the animal for this session
    switch curranm                                  % Switch the marker shape depending on which animal is being plotted
        case uniqueAnm{1}
            shape = 'o';
%         case uniqueAnm{5}
%             shape = '<';
        case uniqueAnm{2}
            shape = '^';
        case uniqueAnm{3}
            shape = 'v';
        case uniqueAnm{4}
            shape = '>';
        case uniqueAnm{5}
            shape = 'square';
        case uniqueAnm{6}
            shape = 'diamond';
        case uniqueAnm{7}
            shape = 'hexagram';
        case uniqueAnm{8}
            shape = 'pentagram';
    end
    scatter(1,delR2_ALL(sessix),markerSize,'filled',shape,'MarkerFaceColor',[0.65 0.65 0.65]); hold on;
end
scatter(1,delR2_ALL(exsess),markerSize,'filled','pentagram','black','MarkerEdgeColor','black')
legend([' ',anmNames_all])
ylim([0.4 1])
ax = gca;
ax.FontSize = 16;
title(['Ex session = Sesh ' num2str(exsess) '; Animal ' anmNames_all{exsess} ])
%% FUNCTIONS
function [avgCD,stdCD] = getAvgStd(trueVals,modelpred,sessix)

avgCD.Rhit.true = mean(mySmooth(trueVals.Rhit{sessix},31),2,'omitnan');      % Get average true CDlate for R and L hits for this session
avgCD.Lhit.true = mean(mySmooth(trueVals.Lhit{sessix},31),2,'omitnan');
stdCD.Rhit.true = std(mySmooth(trueVals.Rhit{sessix},31),0,2,'omitnan');     % Get standard deviation of true CDlate for R and L hits
stdCD.Lhit.true = std(mySmooth(trueVals.Lhit{sessix},31),0,2,'omitnan');

modelpred.Rhit{sessix} = fillmissing(modelpred.Rhit{sessix},"nearest");
modelpred.Lhit{sessix} = fillmissing(modelpred.Lhit{sessix},"nearest");
infix = find(isinf(modelpred.Rhit{sessix})); modelpred.Rhit{sessix}(infix) = 0;
infix = find(isinf(modelpred.Lhit{sessix})); modelpred.Lhit{sessix}(infix) = 0;
avgCD.Rhit.pred = mean(mySmooth(modelpred.Rhit{sessix},31),2,'omitnan');     % Get average predicted CDlate for R and L hits for this session
avgCD.Lhit.pred = mean(mySmooth(modelpred.Lhit{sessix},31),2,'omitnan');
stdCD.Rhit.pred = std(mySmooth(modelpred.Rhit{sessix},31),0,2,'omitnan');    % Get stdev of predicted CDlate for R and L hits for this session
stdCD.Lhit.pred = std(mySmooth(modelpred.Lhit{sessix},31),0,2,'omitnan');
end